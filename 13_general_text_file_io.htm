<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Surpac Tcl/SCL Tutorial - Module 13</title>
    <style>
        body { font-family: sans-serif; line-height: 1.6; color: #333; max-width: 800px; margin: 20px auto; padding: 0 20px; }
        h1, h2, h3 { color: #004488; }
        code { background-color: #f4f4f4; padding: 2px 6px; border-radius: 4px; font-family: "Courier New", Courier, monospace; }
        pre { background-color: #f4f4f4; border: 1px solid #ddd; border-left: 3px solid #004488; padding: 10px; white-space: pre-wrap; word-wrap: break-word; }
        .note { background-color: #e7f3fe; border-left: 6px solid #2196F3; padding: 10px; margin: 20px 0; }
    </style>
</head>
<body>

    <h1>Module 13: General Text File Input/Output</h1>
    <p>While SCL provides powerful commands for working with Surpac's native file formats (like <code>.str</code> and <code>.dtm</code>), you will often need to read from or write to generic text files (e.g., <code>.txt</code>, <code>.csv</code>, custom log files). Tcl has built-in commands for robust file input/output (I/O) that are essential for custom reporting, data exchange with other software, and logging script activity.</p>

    <hr>

    <h2>13.1 Opening and Closing Files</h2>
    <p>
        To work with a file, you first need to open it using the <code>open</code> command. This returns a <strong>file handle</strong>, which you then use for all subsequent operations on that file. When you're finished, it's crucial to close the file using the <code>close</code> command to ensure all data is written and resources are released.
    </p>
    <p>The <code>open</code> command takes two main arguments: the file path and the mode.</p>
    <ul>
        <li><strong>Modes:</strong>
            <ul>
                <li><code>r</code>: Read-only. The file must exist.</li>
                <li><code>w</code>: Write-only. Creates a new file or truncates (empties) an existing one.</li>
                <li><code>a</code>: Append-only. Creates a new file or appends to the end of an existing one.</li>
                <li><code>r+</code>: Read and write. The file must exist.</li>
                <li><code>w+</code>: Read and write. Creates a new file or truncates an existing one.</li>
                <li><code>a+</code>: Read and append. Creates a new file or appends to the end of an existing one.</li>
            </ul>
        </li>
    </ul>
    <pre><code># Open a file for writing (will create or overwrite)
set output_fh [open "my_report.txt" "w"]

# ... write to file ...

# Close the file
close $output_fh

SclMessage "INFO" "Report file created."
</code></pre>

    <hr>

    <h2>13.2 Writing to Files: <code>puts</code></h2>
    <p>
        The <code>puts</code> command is used to write data to a file. You can specify the file handle as the first argument. If no file handle is given, it defaults to writing to the console (or Surpac's message window).
    </p>
    <pre><code>set output_fh [open "my_log.txt" "a"]

puts $output_fh "Script started at [clock format [clock seconds]]"
puts $output_fh "Processing complete."

close $output_fh

SclMessage "INFO" "Log entry added."
</code></pre>

    <hr>

    <h2>13.3 Reading from Files: <code>gets</code> and Loops</h2>
    <p>
        The <code>gets</code> command reads a single line from a file. It returns the number of characters read, or <code>-1</code> if the end of the file is reached. This makes it perfect for reading files line by line within a <code>while</code> loop.
    </p>
    <pre><code># Open a file for reading
set input_fh [open "data.csv" "r"]

SclMessage "INFO" "Reading data.csv:"

# Loop through each line until end of file
while {[gets $input_fh line] >= 0} {
    SclMessage "INFO" "Read line: $line"
    # You can then use string manipulation (Module 14) to parse the line
}

close $input_fh
SclMessage "INFO" "Finished reading data.csv."
</code></pre>

    <hr>

    <h2>13.4 Practical Example: Simple Data Logger</h2>
    <p>This script will log some information to a text file, appending to it if it already exists. It also demonstrates reading a simple CSV-like file.</p>

    <p>Create a file named <code>simple_logger.tcl</code>:</p>
    <pre><code># Simple Data Logger

set log_file "script_activity.log"
set data_file "sample_data.txt"

# --- Write to log file ---
set log_fh [open $log_file "a"]
puts $log_fh "[clock format [clock seconds]] - Script started."

# --- Create a sample data file (if it doesn't exist) ---
if {![file exists $data_file]} {
    set data_fh [open $data_file "w"]
    puts $data_fh "PointID,X,Y,Z"
    puts $data_fh "P1,100.0,200.0,50.0"
    puts $data_fh "P2,105.5,201.2,51.5"
    puts $data_fh "P3,110.1,202.8,52.3"
    close $data_fh
    SclMessage "INFO" "Created sample data file: $data_file"
}

# --- Read from data file and log its content ---
set data_fh [open $data_file "r"]
puts $log_fh "--- Content of $data_file ---"

while {[gets $data_fh line] >= 0} {
    puts $log_fh "  $line"
}
close $data_fh

puts $log_fh "[clock format [clock seconds]] - Script finished."
close $log_fh

SclMessage "INFO" "Activity logged to $log_file"
</code></pre>

    <hr>

    <p><strong>Next Steps:</strong> You can now manage generic text files. In Module 14, we will delve into advanced string and list manipulation techniques, which are crucial for parsing and formatting the data you read from and write to files.</p>

</body>
</html>