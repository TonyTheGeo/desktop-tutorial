<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Surpac Tcl/SCL Tutorial - Module 17</title>
    <style>
        body { font-family: sans-serif; line-height: 1.6; color: #333; max-width: 800px; margin: 20px auto; padding: 0 20px; }
        h1, h2, h3 { color: #004488; }
        code { background-color: #f4f4f4; padding: 2px 6px; border-radius: 4px; font-family: "Courier New", Courier, monospace; }
        pre { background-color: #f4f4f4; border: 1px solid #ddd; border-left: 3px solid #004488; padding: 10px; white-space: pre-wrap; word-wrap: break-word; }
        .note { background-color: #e7f3fe; border-left: 6px solid #2196F3; padding: 10px; margin: 20px 0; }
    </style>
</head>
<body>

    <h1>Module 17: Tcl File System Operations</h1>
    <p>Beyond reading and writing the content of files (as covered in Module 13), Tcl provides a comprehensive set of commands for interacting directly with the file system. This includes tasks like copying, deleting, renaming files, creating and removing directories, and listing files based on patterns. These operations are crucial for managing your project data and organizing script outputs.</p>

    <hr>

    <h2>17.1 The <code>file</code> Command: Managing Files and Directories</h2>
    <p>
        The <code>file</code> command is a versatile Tcl command with many subcommands for file system operations. Here are some of the most commonly used ones:
    </p>
    <ul>
        <li><strong><code>file copy [-force] &lt;source&gt; &lt;target&gt;</code>:</strong> Copies a file. Use <code>-force</code> to overwrite an existing target file.</li>
        <li><strong><code>file delete [-force] &lt;path&gt;</code>:</strong> Deletes a file or an empty directory. Use <code>-force</code> to delete read-only files.</li>
        <li><strong><code>file rename [-force] &lt;source&gt; &lt;target&gt;</code>:</strong> Renames or moves a file or directory. Use <code>-force</code> to overwrite an existing target.</li>
        <li><strong><code>file exists &lt;path&gt;</code>:</strong> Returns <code>1</code> (true) if the file or directory exists, <code>0</code> (false) otherwise. Useful for conditional logic.</li>
        <li><strong><code>file mkdir &lt;path&gt;</code>:</strong> Creates a new directory. It will create parent directories if they don't exist.</li>
        <li><strong><code>file isdirectory &lt;path&gt;</code>:</strong> Returns <code>1</code> if the path is a directory, <code>0</code> otherwise.</li>
        <li><strong><code>file isfile &lt;path&gt;</code>:</strong> Returns <code>1</code> if the path is a regular file, <code>0</code> otherwise.</li>
        <li><strong><code>file extension &lt;path&gt;</code>:</strong> Returns the file extension (e.g., ".str").</li>
        <li><strong><code>file rootname &lt;path&gt;</code>:</strong> Returns the file name without the extension.</li>
        <li><strong><code>file dirname &lt;path&gt;</code>:</strong> Returns the directory name of a path.</li>
        <li><strong><code>file join &lt;path_elements&gt; ...</code>:</strong> Joins path elements correctly for the operating system.</li>
    </ul>
    <pre><code># Example: Copying and deleting files
file copy "input.str" "backup.str"
SclMessage "INFO" "Copied input.str to backup.str"

if {[file exists "old_report.txt"]} {
    file delete "old_report.txt"
    SclMessage "INFO" "Deleted old_report.txt"
}

# Example: Creating a directory and checking existence
set new_dir "./output_data"
if {![file exists $new_dir]} {
    file mkdir $new_dir
    SclMessage "INFO" "Created directory: $new_dir"
}

# Example: Renaming a file
file rename "temp_results.csv" "final_results.csv"
SclMessage "INFO" "Renamed temp_results.csv to final_results.csv"
</code></pre>

    <hr>

    <h2>17.2 The <code>glob</code> Command: Listing Files by Pattern</h2>
    <p>
        The <code>glob</code> command is used to find files and directories that match a specified pattern. This is incredibly useful for processing multiple files that follow a naming convention.
    </p>
    <h3>Syntax</h3>
    <pre><code>glob [-nocomplain] &lt;pattern&gt;</code></pre>
    <ul>
        <li><strong><code>&lt;pattern&gt;</code>:</strong> Can include wildcards like <code>*</code> (matches any sequence of characters), <code>?</code> (matches any single character), and <code>[]</code> (matches characters within a set).</li>
        <li><strong><code>-nocomplain</code>:</strong> Prevents an error if no files match the pattern.</li>
    </ul>
    <pre><code># Example: List all .str files in the current directory
set str_files [glob "*.str"]
SclMessage "INFO" "String files found: $str_files"

# Example: Process all CSV files in a subdirectory
set csv_files [glob "data/*.csv"]
foreach csv_file $csv_files {
    SclMessage "INFO" "Processing CSV: $csv_file"
    # ... your processing logic here ...
}

# Example: Find files starting with 'drill' and ending with .txt or .log
set drill_logs [glob "drill*.{txt,log}"]
SclMessage "INFO" "Drill logs: $drill_logs"
</code></pre>

    <hr>

    <h2>17.3 Practical Example: Batch File Processing</h2>
    <p>This script will find all `.str` files in a specified input directory, process each one (e.g., find its Z-extents using the logic from Module 3), and then log the results to a summary file.</p>

    <p>Create a file named <code>batch_processor.tcl</code>:</p>
    <pre><code># Practical Example: Batch File Processor

set input_dir "./input_strings"
set output_log "./processing_summary.log"

# Ensure input directory exists
if {![file isdirectory $input_dir]} {
    SclMessage "ERROR" "Input directory not found: $input_dir"
    return
}

# Open log file for writing (overwrite if exists)
set log_fh [open $output_log "w"]
puts $log_fh "--- Batch Processing Summary - [clock format [clock seconds]] ---"

# Find all .str files in the input directory
set str_files [glob "$input_dir/*.str"]

if {[llength $str_files] == 0} {
    SclMessage "WARNING" "No .str files found in $input_dir."
    puts $log_fh "No .str files found."
} else {
    SclMessage "INFO" "Found [llength $str_files] string files to process."
    foreach file_path $str_files {
        set file_name [file tail $file_path] ; # Get just the filename
        puts $log_fh "\nProcessing file: $file_name"

        # --- Logic to find Z-extents (from Module 3) ---
        set file_handle [SclSwaOpenFile $file_path]
        set min_z 99999
        set max_z -99999
        set first_point_found 0

        set string_list [SclGetStrings $file_handle]
        foreach string_id $string_list {
            set string_handle [SclGetItem $file_handle "string" $string_id]
            set point_count [SclGetItem $string_handle "count"]

            for {set i 1} {$i <= $point_count} {incr i} {
                set point_handle [SclGetItem $string_handle "point" $i]
                set current_z [SclGetValueByName $point_handle "z"]

                if {$first_point_found == 0} {
                    set min_z $current_z
                    set max_z $current_z
                    set first_point_found 1
                }

                if {$current_z < $min_z} {
                    set min_z $current_z
                }
                if {$current_z > $max_z} {
                    set max_z $current_z
                }
            }
        }
        SclDestroyHandle $file_handle
        # --- End of Z-extents logic ---

        puts $log_fh "  Min Z: [format %.2f $min_z]"
        puts $log_fh "  Max Z: [format %.2f $max_z]"
    }
}

close $log_fh
SclMessage "INFO" "Batch processing complete. See $output_log for summary."
</code></pre>

    <hr>

    <p><strong>Conclusion:</strong> You can now perform comprehensive file system operations and process files in batches, significantly enhancing your automation capabilities in Surpac.</p>

</body>
</html>